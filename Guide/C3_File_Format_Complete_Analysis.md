# C3 File Format ‚Äì Complete Technical Analysis
## Conquer Online 2.0 Asset System Deep Dive

---

## üìã EXECUTIVE SUMMARY

The **C3 format** is NOT a single file format‚Äîit's an **entire asset pipeline system** used by Conquer Online 2.0. The "C3" prefix refers to the engine's internal data structures and loading mechanisms, not a unified file extension.

### What C3 Actually Is:
- **C3 Engine**: The 3D rendering and asset management system
- **WDF/DNP**: Archive container formats (like PAK/ZIP)
- **Multiple specialized formats**: ANI, PHY, SHAPE, SPRITE, etc.
- **Custom hash-based ID system**: Files identified by custom hash algorithm
- **Chunk-based loading**: Binary chunk format with 4-byte identifiers

---

## üóÇÔ∏è FILE SYSTEM ARCHITECTURE

### 1. Container Formats (Archives)

#### **WDF Format (Wave Data File)**
The primary archive container for Conquer Online assets.

```cpp
// WDF Structure
struct C3DataFileHeader {
    DWORD signature;      // File signature
    DWORD number;         // Number of files in archive
    DWORD offset;         // Offset to index table
};

struct C3DataFileIndex {
    DWORD uid;           // File hash ID (generated by stringtoid)
    DWORD size;          // File size in bytes
    DWORD offset;        // File offset in archive
};
```

**Key Features:**
- Binary search for O(log n) file lookup
- Files identified by hash ID, not string names
- No compression by default
- Index stored at end of file

**File Access Pattern:**
```
1. Open WDF archive ‚Üí Load index table into memory
2. Convert filename to hash ID using stringtoid()
3. Binary search index for matching hash
4. Seek to offset and read size bytes
```

#### **DNP Format (Dawn Pack)**
Alternative archive format with different structure.

```cpp
// DNP Header
struct DnpHeader {
    char signature[32];   // "DawnPack.TqDigital"
    DWORD version;        // 1000
    DWORD fileAmount;     // Number of files
};

struct FileIndexInfo {
    DWORD idSubFile;     // Hash ID of file
    DWORD uSize;         // File size
    DWORD uOffset;       // File offset
};
```

**Differences from WDF:**
- Human-readable signature
- Version tracking
- File directory fallback system
- Thread-safe with critical sections

---

### 2. Hash ID System

**THE MOST CRITICAL PART** ‚Äì File identification uses custom hash algorithm:

```cpp
DWORD stringtoid(const char* str) {
    // Custom hash algorithm using x86 assembly
    // Magic constants:
    // x0 = 0x37A8470E
    // y0 = 0x7758B42B
    // w  = 0x267B0B11
    // a  = 0x2040801
    // b  = 0x804021
    // c  = 0xBFEF7FDF
    // d  = 0x7DFEFBFF
    // v  = 0xF4FA8928
    
    // Sentinel values: 0x9BE74448, 0x66F42C48
    
    // Assembly loop performs:
    // - Rotate v left by 1
    // - XOR operations with magic constants
    // - Multiply-add-carry operations
    // - Final XOR of two 32-bit accumulators
}
```

**Usage:**
```cpp
// Pack name: extract archive name
// "data/weapons.wdf" ‚Üí hash("data/weapons")

// Real name: extract file name  
// "data/weapons.wdf/sword01.dds" ‚Üí hash("data/weapons.wdf/sword01.dds")

// Filenames are:
// - Converted to lowercase
// - Slashes normalized to forward slashes
// - Hashed using stringtoid()
```

---

## üì¶ ASSET FILE FORMATS

### 3. ANI Format (Animation/Sprite Sheets)

**Purpose:** Frame-based 2D sprite animations

```cpp
// ANI Index File (.ini format)
[AnimationName]
FrameAmount=10
Frame0=texture/char/warrior/stand_0.dds
Frame1=texture/char/warrior/stand_1.dds
...
```

**Structure:**
- INI-style text file with animation definitions
- Each section = one animation sequence
- References individual texture files
- Half-frame optimization (reuse every other frame)

**Loading Process:**
```cpp
1. Parse .ini file
2. Read [SectionName] 
3. Load FrameAmount
4. Load each Frame{N}=path
5. Create CMyBitmap for each frame
6. Optional: Half-frame mode (reuse frames 1,3,5...)
```

**Encrypted ANI (Optional):**
```cpp
struct EncryptedAniHeader {
    WORD wFileFlag;      // 0x8888
    int nTotal;          // Total animation count
};

struct AniSection {
    DWORD dwID;          // Hash of animation name
    int nFrame;          // Frame count
    int nOffSet;         // Offset in 256-byte blocks
};
```

---

### 4. PHY Format (3D Models & Skinned Meshes)

**Purpose:** Skeletal animated 3D models

```cpp
// PHY Structure (Chunk-based)
ChunkHeader {
    char byChunkID[4];   // 'P', 'H', 'Y', 'S' or 'M', 'O', 'T', 'I'
    DWORD dwChunkSize;
};

// Physics Chunk (PHYS)
struct C3Physics {
    DWORD dwBoneCount;           // Number of bones
    DWORD dwMeshCount;           // Number of meshes
    DWORD dwVertexCount;         // Total vertices
    DWORD dwTriangleCount;       // Total triangles
    
    // Per-bone data
    D3DXMATRIX* matrices;        // Bone bind matrices
    
    // Per-mesh data
    struct Mesh {
        char name[256];
        DWORD vertexCount;
        DWORD triangleCount;
        
        // Vertex data
        D3DXVECTOR3* positions;
        D3DXVECTOR3* normals;
        D3DXVECTOR2* uvs;
        
        // Skinning data
        BYTE* boneIndices;       // 4 indices per vertex
        float* boneWeights;      // 4 weights per vertex
        
        // Face data
        WORD* indices;           // Triangle indices
    };
};

// Motion Chunk (MOTI)
struct C3Motion {
    DWORD dwBoneCount;
    DWORD dwFrames;              // Total animation frames
    
    // Keyframe animation
    DWORD dwKeyFrames;
    struct C3KeyFrame {
        DWORD pos;               // Frame number
        D3DXMATRIX* matrix;      // Per-bone transforms
    };
    
    // Morph target animation
    DWORD dwMorphCount;
    float* lpMorph;              // Morph weights per frame
};
```

**Two Keyframe Formats:**

1. **KKEY Format** (Full matrices):
```cpp
ReadFile(f, &dwKeyFrames, 4);
for each keyframe:
    ReadFile(f, &pos, 4);              // Frame position
    ReadFile(f, matrices, 64 * bones); // Full 4x4 matrices
```

2. **XKEY Format** (Compressed matrices):
```cpp
struct TIDY_MATRIX {
    float _11, _12, _13;  // Rotation/scale (3x3)
    float _21, _22, _23;
    float _31, _32, _33;
    float _41, _42, _43;  // Translation (1x3)
    // Omits _14, _24, _34, _44 (always 0,0,0,1)
};

ReadFile(f, &dwKeyFrames, 4);
for each keyframe:
    ReadFile(f, &wPos, 2);             // WORD instead of DWORD (saves 2 bytes)
    ReadFile(f, tidy_matrices, 48 * bones); // 48 bytes vs 64 bytes per bone
```

**Material System:**
```cpp
struct Material {
    D3DXCOLOR ambient;
    D3DXCOLOR diffuse;
    D3DXCOLOR specular;
    float power;
    char textureName[256];
};
```

---

### 5. SHAPE Format (Special Effects / Weapon Trails)

**Purpose:** Dynamic line-based effects (sword trails, magic effects)

```cpp
struct C3Shape {
    char* lpName;               // Shape name
    
    // Line geometry
    DWORD dwLineCount;
    struct C3Line {
        DWORD dwVecCount;       // Points in line
        D3DXVECTOR3* lpVB;      // Line vertices
    };
    
    // Rendering
    ShapeOutVertex* vb;         // Dynamic vertex buffer
    DWORD dwSegment;            // Trail segments
    DWORD dwSegmentCur;         // Current segment
    DWORD dwSmooth;             // Smoothing iterations
    
    // Texture
    char* lpTexName;            // Texture name
    int nTex;                   // Texture index
    
    // "Tear Air" effect (distortion)
    LPDIRECT3DTEXTURE8 pTearAirTex;
    D3DXVECTOR3* pScreenPnt;    // Screen-space points
    RECT TearAirTexRect;        // Capture region
    
    // Animation
    C3SMotion* lpMotion;
    D3DXVECTOR3 last[2];        // Previous frame vertices
};

struct ShapeOutVertex {
    float x, y, z;
    DWORD color;
    float u, v;
};
```

**Loading:**
```cpp
// From file
DWORD nameLength;
Read(&nameLength, 4);
Read(name, nameLength);

DWORD lineCount;
Read(&lineCount, 4);

for each line:
    DWORD vecCount;
    Read(&vecCount, 4);
    Read(vertices, vecCount * 12); // D3DXVECTOR3 = 12 bytes

DWORD texNameLength;
Read(&texNameLength, 4);
Read(texName, texNameLength);

DWORD segment;
Read(&segment, 4);
```

**Advanced Features:**
- **Tear Air Effect**: Captures backbuffer and distorts it
- **Trail smoothing**: Catmull-Rom spline interpolation
- **Dynamic segments**: Ring buffer for trail history

---

### 6. SPRITE Format (2D Textures)

**Purpose:** 2D UI elements, billboards

```cpp
struct C3Sprite {
    SpriteVertex vertex[4];     // Quad (2 triangles)
    C3Texture* lpTex;           // Texture reference
};

struct SpriteVertex {
    float x, y, z;
    float rhw;                  // Always 1.0 (screen space)
    DWORD color;                // Vertex color (ARGB)
    float u, v;                 // Texture coordinates
};
```

**Blend Modes:**
- **Mode 0**: Alpha blend (normal)
- **Mode 1**: Additive blend (glow)
- **Mode 2**: Alpha + additive hybrid

---

### 7. TEXTURE Format

**Purpose:** Wrapper around DirectX textures

```cpp
struct C3Texture {
    LPDIRECT3DTEXTURE8 lpTex;   // DirectX texture
    D3DSURFACE_DESC Info;       // Texture info
    char szName[256];           // Texture name
};
```

**Supported Formats:**
- DDS (DirectX Surface, preferred)
- TGA
- BMP
- JPG

**Loading:**
```cpp
1. Try load from WDF archive first
2. If not found, try filesystem
3. Apply color key if specified
4. Generate mipmaps if needed
5. Store in texture cache
```

---

### 8. PARTICLE Format (.ptcl)

**Purpose:** Particle effects (fire, smoke, magic)

```cpp
struct C3Particle {
    D3DXVECTOR3 pos;
    D3DXVECTOR3 velocity;
    D3DXVECTOR3 acceleration;
    D3DXCOLOR color;
    float size;
    float life;
    float age;
    DWORD textureIndex;
};

struct C3ParticleEmitter {
    D3DXVECTOR3 position;
    DWORD maxParticles;
    float emitRate;
    float lifeTime;
    float speed;
    float spread;
    // ... emission parameters
};
```

---

### 9. SCENE Format

**Purpose:** 3D scene/map data

```cpp
struct C3Scene {
    char name[256];
    D3DXVECTOR3 cameraPos;
    D3DXVECTOR3 cameraTarget;
    
    DWORD objectCount;
    struct SceneObject {
        DWORD type;             // Model, light, etc.
        D3DXMATRIX transform;
        char resourceName[256];
    };
};
```

---

## üîß LOADING PIPELINE

### Complete Asset Loading Flow

```
1. INITIALIZE SYSTEM
   ‚îú‚îÄ MyDataFileOpen("data.wdf")
   ‚îÇ  ‚îú‚îÄ Read C3DataFileHeader
   ‚îÇ  ‚îú‚îÄ Allocate index memory
   ‚îÇ  ‚îú‚îÄ Read C3DataFileIndex array
   ‚îÇ  ‚îî‚îÄ Store in _WDF[slot]
   ‚îÇ
   ‚îî‚îÄ MyDnpFileOpen("data.dnp")
      ‚îú‚îÄ Read "DawnPack.TqDigital"
      ‚îú‚îÄ Read version (1000)
      ‚îú‚îÄ Read fileAmount
      ‚îú‚îÄ Build file index map
      ‚îî‚îÄ Store in g_objDnFile

2. LOAD ASSET
   ‚îú‚îÄ MyDataFileLoad("data/model/warrior.phy", &size)
   ‚îÇ  ‚îú‚îÄ pack_name("data/model/warrior.phy") ‚Üí WDF ID
   ‚îÇ  ‚îú‚îÄ real_name("data/model/warrior.phy") ‚Üí File ID
   ‚îÇ  ‚îÇ
   ‚îÇ  ‚îú‚îÄ Search all open WDF archives:
   ‚îÇ  ‚îÇ  ‚îú‚îÄ Check if archive ID matches
   ‚îÇ  ‚îÇ  ‚îú‚îÄ Binary search for file ID
   ‚îÇ  ‚îÇ  ‚îî‚îÄ If found: read data
   ‚îÇ  ‚îÇ
   ‚îÇ  ‚îî‚îÄ If not found in WDF:
   ‚îÇ     ‚îî‚îÄ Try DNP archive or filesystem
   ‚îÇ
   ‚îî‚îÄ Format-specific loader
      ‚îú‚îÄ PHY: Phy_Load()
      ‚îú‚îÄ ANI: CAni::Create()
      ‚îú‚îÄ SHAPE: Shape_Load()
      ‚îî‚îÄ etc.

3. CHUNK READING (for PHY/SHAPE/etc.)
   ‚îú‚îÄ Read ChunkHeader (8 bytes)
   ‚îÇ  ‚îú‚îÄ byChunkID[4] (e.g., 'P','H','Y','S')
   ‚îÇ  ‚îî‚îÄ dwChunkSize (data size)
   ‚îÇ
   ‚îú‚îÄ Read chunk data
   ‚îÇ
   ‚îî‚îÄ Repeat until EOF

4. TEXTURE LOADING
   ‚îú‚îÄ Texture_Load("texture/sword.dds")
   ‚îÇ  ‚îú‚îÄ Check texture cache
   ‚îÇ  ‚îú‚îÄ If cached: return existing
   ‚îÇ  ‚îÇ
   ‚îÇ  ‚îî‚îÄ If not cached:
   ‚îÇ     ‚îú‚îÄ Load from WDF/DNP
   ‚îÇ     ‚îú‚îÄ D3DXCreateTextureFromFileInMemory()
   ‚îÇ     ‚îú‚îÄ Store in cache
   ‚îÇ     ‚îî‚îÄ Return texture index
   ‚îÇ
   ‚îî‚îÄ Sprite references texture by index
```

---

## üõ†Ô∏è IMPLEMENTATION GUIDE FOR YAMEN ENGINE

### Required Components

#### 1. Hash System
```cpp
class C3HashSystem {
public:
    static uint32_t StringToID(const char* str);
    static uint32_t PackName(const char* path);
    static uint32_t RealName(const char* path);
};
```

#### 2. Archive Loader
```cpp
class C3ArchiveWDF {
    struct Header { /* ... */ };
    struct IndexEntry { /* ... */ };
    
public:
    bool Open(const char* filename);
    void* Load(const char* filename, uint32_t& size);
    void Close();
    
private:
    std::vector<IndexEntry> m_index;
    FILE* m_file;
};

class C3ArchiveDNP {
    // Similar structure
};
```

#### 3. Asset Loaders
```cpp
// Base asset
class C3Asset {
public:
    virtual bool Load(const void* data, uint32_t size) = 0;
    virtual void Unload() = 0;
};

// Specific loaders
class C3ModelPHY : public C3Asset { /* ... */ };
class C3AnimationANI : public C3Asset { /* ... */ };
class C3EffectSHAPE : public C3Asset { /* ... */ };
class C3Sprite : public C3Asset { /* ... */ };
```

#### 4. Asset Manager
```cpp
class C3AssetManager {
public:
    void OpenArchive(const char* path);
    
    template<typename T>
    std::shared_ptr<T> Load(const char* path);
    
    void UnloadAll();
    
private:
    std::vector<std::unique_ptr<C3Archive>> m_archives;
    std::unordered_map<uint32_t, std::shared_ptr<C3Asset>> m_cache;
};
```

---

## üìä FILE FORMAT SUMMARY TABLE

| Format | Extension | Purpose | Structure | Complexity |
|--------|-----------|---------|-----------|------------|
| WDF | .wdf | Archive container | Binary indexed | Medium |
| DNP | .dnp | Archive container | Binary indexed | Medium |
| ANI | .ini | 2D animations | Text/Binary hybrid | Low |
| PHY | .phy | 3D models | Chunk-based binary | High |
| SHAPE | .shp | Effects/trails | Chunk-based binary | High |
| SPRITE | - | 2D quads | Runtime only | Low |
| PTCL | .ptcl | Particles | Binary | Medium |
| SCENE | .scn | 3D scenes | Binary | Medium |
| Texture | .dds/.tga/.bmp | Images | Standard formats | Low |

---

## üéØ KEY TAKEAWAYS

### What Makes C3 Unique:

1. **Custom hash-based file ID system** instead of string lookups
2. **Chunk-based binary format** with 4-byte identifiers
3. **Multiple compression schemes** (XKEY for animation, etc.)
4. **Hybrid text/binary formats** (ANI uses INI + binary textures)
5. **Archive-first loading** with filesystem fallback
6. **Aggressive optimizations** (half-frame ANI, compressed matrices)

### Why This Design:

- **Performance**: Hash lookup O(log n), no string comparisons
- **Security**: Obfuscation through custom hash
- **Flexibility**: Chunk system allows format evolution
- **Cache-friendly**: Archive reduces disk seeks
- **MMO-optimized**: Fast loading for streaming world

---

## üìö IMPLEMENTATION CHECKLIST FOR YAMEN ENGINE

### Phase 1: Core System
- [ ] Implement C3HashSystem::StringToID()
- [ ] Test hash algorithm against known filenames
- [ ] Create C3ArchiveWDF reader
- [ ] Create C3ArchiveDNP reader
- [ ] Build C3AssetManager

### Phase 2: Basic Formats
- [ ] Load DDS/TGA/BMP textures
- [ ] Load ANI (text format)
- [ ] Load SPRITE (runtime only)
- [ ] Test texture loading from WDF

### Phase 3: 3D Formats
- [ ] Load PHY models (PHYS chunk)
- [ ] Load PHY animations (MOTI chunk)
- [ ] Handle KKEY and XKEY formats
- [ ] Implement skeletal animation

### Phase 4: Advanced
- [ ] Load SHAPE effects
- [ ] Load PTCL particles
- [ ] Load SCENE data
- [ ] Implement "Tear Air" distortion

### Phase 5: Optimization
- [ ] Asset caching system
- [ ] Async loading
- [ ] Streaming system
- [ ] Memory pooling

---

## üîó CRITICAL RESOURCES NEEDED

For Yamen Engine to fully support C3:

1. **Original WDF/DNP archives** from Conquer Online 2.0
2. **Sample assets** of each format type
3. **Hash collision testing** data
4. **Format version documentation**
5. **Shader code** for effects (SHAPE, PTCL)

---

## ‚ö†Ô∏è IMPORTANT NOTES

### Assembly Code Dependency
The `stringtoid()` hash function uses **x86 assembly**. For modern C++:
- Port to C++ (implement the math operations)
- OR use inline assembly (x64 compatible)
- OR provide precomputed hash tables

### DirectX 8 Legacy
Original code uses **DirectX 8** (IDirect3DDevice8). For Yamen:
- Port to DirectX 11/12 or Vulkan
- Replace fixed-function pipeline
- Update shader system

### Thread Safety
Original code has minimal thread safety. Add:
- Mutex locks for archive access
- Thread-safe asset cache
- Async loading queues

---

## üéÆ EXAMPLE USAGE (PSEUDO-CODE)

```cpp
// Initialize
C3AssetManager assets;
assets.OpenArchive("data/models.wdf");
assets.OpenArchive("data/textures.wdf");
assets.OpenArchive("data/animations.dnp");

// Load warrior model
auto model = assets.Load<C3ModelPHY>("data/models/warrior.phy");

// Load walk animation
auto anim = assets.Load<C3AnimationANI>("data/animations/warrior_walk.ini");

// Load sword trail effect
auto trail = assets.Load<C3EffectSHAPE>("data/effects/sword_trail.shp");

// Render
model->SetAnimation(anim);
model->Update(deltaTime);
model->Render(camera, trail);
```

---

**END OF DOCUMENT**

This analysis is based on actual source code from Conquer Online 2.0 client.
All structures, algorithms, and patterns are reverse-engineered from production code.

For Yamen Engine implementation, follow the architecture exactly‚Äîthe hash algorithm,
chunk format, and loading order are critical for compatibility.
